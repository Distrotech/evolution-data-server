/*
 * Generated by gdbus-codegen.py 0.1. DO NOT EDIT.
 */

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif

#include "e-gdbus-emailsession.h"

typedef struct
{
  GDBusArgInfo parent_struct;
  gboolean use_gvariant;
} _ExtendedGDBusArgInfo;

typedef struct
{
  GDBusMethodInfo parent_struct;
  const gchar *signal_name;
} _ExtendedGDBusMethodInfo;

typedef struct
{
  GDBusSignalInfo parent_struct;
  const gchar *signal_name;
} _ExtendedGDBusSignalInfo;

typedef struct
{
  GDBusPropertyInfo parent_struct;
  const gchar *hyphen_name;
  gboolean use_gvariant;
} _ExtendedGDBusPropertyInfo;

typedef struct
{
  const _ExtendedGDBusPropertyInfo *info;
  GParamSpec *pspec;
  GValue value;
} ChangedProperty;

static void
_changed_property_free (ChangedProperty *data)
{
  g_value_unset (&data->value);
  g_free (data);
}

static gboolean
_g_strv_equal0 (gchar **a, gchar **b)
{
  gboolean ret = FALSE;
  guint n;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  if (g_strv_length (a) != g_strv_length (b))
    goto out;
  for (n = 0; a[n] != NULL; n++)
    if (g_strcmp0 (a[n], b[n]) != 0)
      goto out;
  ret = TRUE;
out:
  return ret;
}

static gboolean
_g_variant_equal0 (GVariant *a, GVariant *b)
{
  gboolean ret = FALSE;
  if (a == NULL && b == NULL)
    goto out;
  if (a == NULL || b == NULL)
    goto out;
  ret = g_variant_equal (a, b);
out:
  return ret;
}

static gboolean
_g_value_equal (const GValue *a, const GValue *b)
{
  gboolean ret = FALSE;
  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
  switch (G_VALUE_TYPE (a))
    {
      case G_TYPE_BOOLEAN:
        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
        break;
      case G_TYPE_UCHAR:
        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
        break;
      case G_TYPE_INT:
        ret = (g_value_get_int (a) == g_value_get_int (b));
        break;
      case G_TYPE_UINT:
        ret = (g_value_get_uint (a) == g_value_get_uint (b));
        break;
      case G_TYPE_INT64:
        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
        break;
      case G_TYPE_UINT64:
        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
        break;
      case G_TYPE_DOUBLE:
        ret = (g_value_get_double (a) == g_value_get_double (b));
        break;
      case G_TYPE_STRING:
        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
        break;
      case G_TYPE_VARIANT:
        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
        break;
      default:
        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
        else
          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
        break;
    }
  return ret;
}

#include <ffi.h>
static ffi_type *
value_to_ffi_type (const GValue *gvalue, gpointer *value)
{
  ffi_type *rettype = NULL;
  GType type = g_type_fundamental (G_VALUE_TYPE (gvalue));
  g_assert (type != G_TYPE_INVALID);

  switch (type)
    {
    case G_TYPE_BOOLEAN:
    case G_TYPE_CHAR:
    case G_TYPE_INT:
      rettype = &ffi_type_sint;
      *value = (gpointer)&(gvalue->data[0].v_int);
      break;
    case G_TYPE_UCHAR:
    case G_TYPE_UINT:
      rettype = &ffi_type_uint;
      *value = (gpointer)&(gvalue->data[0].v_uint);
      break;
    case G_TYPE_STRING:
    case G_TYPE_OBJECT:
    case G_TYPE_BOXED:
    case G_TYPE_POINTER:
    case G_TYPE_INTERFACE:
    case G_TYPE_VARIANT:
      rettype = &ffi_type_pointer;
      *value = (gpointer)&(gvalue->data[0].v_pointer);
      break;
    case G_TYPE_FLOAT:
      rettype = &ffi_type_float;
      *value = (gpointer)&(gvalue->data[0].v_float);
      break;
    case G_TYPE_DOUBLE:
      rettype = &ffi_type_double;
      *value = (gpointer)&(gvalue->data[0].v_double);
      break;
    case G_TYPE_LONG:
      rettype = &ffi_type_slong;
      *value = (gpointer)&(gvalue->data[0].v_long);
      break;
    case G_TYPE_ULONG:
      rettype = &ffi_type_ulong;
      *value = (gpointer)&(gvalue->data[0].v_ulong);
      break;
    case G_TYPE_INT64:
      rettype = &ffi_type_sint64;
      *value = (gpointer)&(gvalue->data[0].v_int64);
      break;
    case G_TYPE_UINT64:
      rettype = &ffi_type_uint64;
      *value = (gpointer)&(gvalue->data[0].v_uint64);
      break;
    default:
      rettype = &ffi_type_pointer;
      *value = NULL;
      g_warning ("value_to_ffi_type: Unsupported fundamental type: %s", g_type_name (type));
      break;
    }
  return rettype;
}

static void
value_from_ffi_type (GValue *gvalue, gpointer *value)
{
  switch (g_type_fundamental (G_VALUE_TYPE (gvalue)))
    {
    case G_TYPE_INT:
      g_value_set_int (gvalue, *(gint*)value);
      break;
    case G_TYPE_FLOAT:
      g_value_set_float (gvalue, *(gfloat*)value);
      break;
    case G_TYPE_DOUBLE:
      g_value_set_double (gvalue, *(gdouble*)value);
      break;
    case G_TYPE_BOOLEAN:
      g_value_set_boolean (gvalue, *(gboolean*)value);
      break;
    case G_TYPE_STRING:
      g_value_set_string (gvalue, *(gchar**)value);
      break;
    case G_TYPE_CHAR:
      g_value_set_char (gvalue, *(gchar*)value);
      break;
    case G_TYPE_UCHAR:
      g_value_set_uchar (gvalue, *(guchar*)value);
      break;
    case G_TYPE_UINT:
      g_value_set_uint (gvalue, *(guint*)value);
      break;
    case G_TYPE_POINTER:
      g_value_set_pointer (gvalue, *(gpointer*)value);
      break;
    case G_TYPE_LONG:
      g_value_set_long (gvalue, *(glong*)value);
      break;
    case G_TYPE_ULONG:
      g_value_set_ulong (gvalue, *(gulong*)value);
      break;
    case G_TYPE_INT64:
      g_value_set_int64 (gvalue, *(gint64*)value);
      break;
    case G_TYPE_UINT64:
      g_value_set_uint64 (gvalue, *(guint64*)value);
      break;
    case G_TYPE_BOXED:
      g_value_set_boxed (gvalue, *(gpointer*)value);
      break;
    default:
      g_warning ("value_from_ffi_type: Unsupported fundamental type: %s",
                g_type_name (g_type_fundamental (G_VALUE_TYPE (gvalue))));
    }
}

static void
_cclosure_marshal_generic (GClosure *closure,
                             GValue *return_gvalue,
                             guint n_param_values,
                             const GValue *param_values,
                             gpointer invocation_hint,
                             gpointer marshal_data)
{
  ffi_type *rtype;
  void *rvalue;
  int n_args;
  ffi_type **atypes;
  void **args;
  int i;
  ffi_cif cif;
  GCClosure *cc = (GCClosure*) closure;

  if (return_gvalue && G_VALUE_TYPE (return_gvalue)) 
    {
      rtype = value_to_ffi_type (return_gvalue, &rvalue);
    }
  else 
    {
      rtype = &ffi_type_void;
    }

  rvalue = g_alloca (MAX (rtype->size, sizeof (ffi_arg)));
  
  n_args = n_param_values + 1;
  atypes = g_alloca (sizeof (ffi_type *) * n_args);
  args =  g_alloca (sizeof (gpointer) * n_args);

  if (G_CCLOSURE_SWAP_DATA (closure))
    {
      atypes[n_args-1] = value_to_ffi_type (param_values + 0,  
                                            &args[n_args-1]);
      atypes[0] = &ffi_type_pointer;
      args[0] = &closure->data;
    }
  else
    {
      atypes[0] = value_to_ffi_type (param_values + 0, &args[0]);
      atypes[n_args-1] = &ffi_type_pointer;
      args[n_args-1] = &closure->data;
    }

  for (i = 1; i < n_args - 1; i++)
    atypes[i] = value_to_ffi_type (param_values + i, &args[i]);

  if (ffi_prep_cif (&cif, FFI_DEFAULT_ABI, n_args, rtype, atypes) != FFI_OK)
    return;

  ffi_call (&cif, marshal_data ? marshal_data : cc->callback, rvalue, args);

  if (return_gvalue && G_VALUE_TYPE (return_gvalue))
    value_from_ffi_type (return_gvalue, rvalue);
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.evolution.dataserver.mail.Session
 * ------------------------------------------------------------------------
 */

/* ---- Introspection data for org.gnome.evolution.dataserver.mail.Session ---- */

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_get_store_IN_ARG_uri =
{
  {
    -1,
    "uri",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_method_info_get_store_IN_ARG_pointers[] =
{
  &_egdbus_session_cs_method_info_get_store_IN_ARG_uri,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_get_store_OUT_ARG_store =
{
  {
    -1,
    "store",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_method_info_get_store_OUT_ARG_pointers[] =
{
  &_egdbus_session_cs_method_info_get_store_OUT_ARG_store,
  NULL
};

static const GDBusAnnotationInfo _egdbus_session_cs_method_get_store_annotation_info_0 =
{
  -1,
  "org.freedesktop.DBus.GLib.CSymbol",
  "impl_Mail_Session_getStore",
  NULL
};

static const GDBusAnnotationInfo _egdbus_session_cs_method_get_store_annotation_info_1 =
{
  -1,
  "org.freedesktop.DBus.GLib.Async",
  "",
  NULL
};

static const GDBusAnnotationInfo * const _egdbus_session_cs_method_get_store_annotation_info_pointers[] =
{
  &_egdbus_session_cs_method_get_store_annotation_info_0,
  &_egdbus_session_cs_method_get_store_annotation_info_1,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_session_cs_method_info_get_store =
{
  {
    -1,
    "getStore",
    (GDBusArgInfo **) &_egdbus_session_cs_method_info_get_store_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_session_cs_method_info_get_store_OUT_ARG_pointers,
    (GDBusAnnotationInfo **) &_egdbus_session_cs_method_get_store_annotation_info_pointers
  },
  "handle-get-store"
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_get_local_store_OUT_ARG_store =
{
  {
    -1,
    "store",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_method_info_get_local_store_OUT_ARG_pointers[] =
{
  &_egdbus_session_cs_method_info_get_local_store_OUT_ARG_store,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_session_cs_method_info_get_local_store =
{
  {
    -1,
    "getLocalStore",
    NULL,
    (GDBusArgInfo **) &_egdbus_session_cs_method_info_get_local_store_OUT_ARG_pointers,
    NULL
  },
  "handle-get-local-store"
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_add_password_IN_ARG_key =
{
  {
    -1,
    "key",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_add_password_IN_ARG_password =
{
  {
    -1,
    "password",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_add_password_IN_ARG_remember =
{
  {
    -1,
    "remember",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_method_info_add_password_IN_ARG_pointers[] =
{
  &_egdbus_session_cs_method_info_add_password_IN_ARG_key,
  &_egdbus_session_cs_method_info_add_password_IN_ARG_password,
  &_egdbus_session_cs_method_info_add_password_IN_ARG_remember,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_session_cs_method_info_add_password =
{
  {
    -1,
    "addPassword",
    (GDBusArgInfo **) &_egdbus_session_cs_method_info_add_password_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-add-password"
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_get_local_folder_IN_ARG_type =
{
  {
    -1,
    "type",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_method_info_get_local_folder_IN_ARG_pointers[] =
{
  &_egdbus_session_cs_method_info_get_local_folder_IN_ARG_type,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_get_local_folder_OUT_ARG_folder =
{
  {
    -1,
    "folder",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_method_info_get_local_folder_OUT_ARG_pointers[] =
{
  &_egdbus_session_cs_method_info_get_local_folder_OUT_ARG_folder,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_session_cs_method_info_get_local_folder =
{
  {
    -1,
    "getLocalFolder",
    (GDBusArgInfo **) &_egdbus_session_cs_method_info_get_local_folder_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_session_cs_method_info_get_local_folder_OUT_ARG_pointers,
    NULL
  },
  "handle-get-local-folder"
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_get_folder_from_uri_IN_ARG_uri =
{
  {
    -1,
    "uri",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_method_info_get_folder_from_uri_IN_ARG_pointers[] =
{
  &_egdbus_session_cs_method_info_get_folder_from_uri_IN_ARG_uri,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_get_folder_from_uri_OUT_ARG_folder =
{
  {
    -1,
    "folder",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_method_info_get_folder_from_uri_OUT_ARG_pointers[] =
{
  &_egdbus_session_cs_method_info_get_folder_from_uri_OUT_ARG_folder,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_session_cs_method_info_get_folder_from_uri =
{
  {
    -1,
    "getFolderFromUri",
    (GDBusArgInfo **) &_egdbus_session_cs_method_info_get_folder_from_uri_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_session_cs_method_info_get_folder_from_uri_OUT_ARG_pointers,
    NULL
  },
  "handle-get-folder-from-uri"
};

static const _ExtendedGDBusMethodInfo _egdbus_session_cs_method_info_send_receive =
{
  {
    -1,
    "sendReceive",
    NULL,
    NULL,
    NULL
  },
  "handle-send-receive"
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_fetch_account_IN_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_method_info_fetch_account_IN_ARG_pointers[] =
{
  &_egdbus_session_cs_method_info_fetch_account_IN_ARG_uid,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_session_cs_method_info_fetch_account =
{
  {
    -1,
    "fetchAccount",
    (GDBusArgInfo **) &_egdbus_session_cs_method_info_fetch_account_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-fetch-account"
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_fetch_old_messages_IN_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_fetch_old_messages_IN_ARG_count =
{
  {
    -1,
    "count",
    "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_method_info_fetch_old_messages_IN_ARG_pointers[] =
{
  &_egdbus_session_cs_method_info_fetch_old_messages_IN_ARG_uid,
  &_egdbus_session_cs_method_info_fetch_old_messages_IN_ARG_count,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_method_info_fetch_old_messages_OUT_ARG_success =
{
  {
    -1,
    "success",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_method_info_fetch_old_messages_OUT_ARG_pointers[] =
{
  &_egdbus_session_cs_method_info_fetch_old_messages_OUT_ARG_success,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_session_cs_method_info_fetch_old_messages =
{
  {
    -1,
    "fetchOldMessages",
    (GDBusArgInfo **) &_egdbus_session_cs_method_info_fetch_old_messages_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_session_cs_method_info_fetch_old_messages_OUT_ARG_pointers,
    NULL
  },
  "handle-fetch-old-messages"
};

static const _ExtendedGDBusMethodInfo _egdbus_session_cs_method_info_cancel_operations =
{
  {
    -1,
    "cancelOperations",
    NULL,
    NULL,
    NULL
  },
  "handle-cancel-operations"
};

static const _ExtendedGDBusMethodInfo * const _egdbus_session_cs_method_info_pointers[] =
{
  &_egdbus_session_cs_method_info_get_store,
  &_egdbus_session_cs_method_info_get_local_store,
  &_egdbus_session_cs_method_info_add_password,
  &_egdbus_session_cs_method_info_get_local_folder,
  &_egdbus_session_cs_method_info_get_folder_from_uri,
  &_egdbus_session_cs_method_info_send_receive,
  &_egdbus_session_cs_method_info_fetch_account,
  &_egdbus_session_cs_method_info_fetch_old_messages,
  &_egdbus_session_cs_method_info_cancel_operations,
  NULL
};

static const _ExtendedGDBusSignalInfo _egdbus_session_cs_signal_info_send_receive_complete =
{
  {
    -1,
    "sendReceiveComplete",
    NULL,
    NULL
  },
  "send-receive-complete"
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_signal_info_account_added_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_signal_info_account_added_ARG_pointers[] =
{
  &_egdbus_session_cs_signal_info_account_added_ARG_uid,
  NULL
};

static const _ExtendedGDBusSignalInfo _egdbus_session_cs_signal_info_account_added =
{
  {
    -1,
    "AccountAdded",
    (GDBusArgInfo **) &_egdbus_session_cs_signal_info_account_added_ARG_pointers,
    NULL
  },
  "account-added"
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_signal_info_account_removed_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_signal_info_account_removed_ARG_pointers[] =
{
  &_egdbus_session_cs_signal_info_account_removed_ARG_uid,
  NULL
};

static const _ExtendedGDBusSignalInfo _egdbus_session_cs_signal_info_account_removed =
{
  {
    -1,
    "AccountRemoved",
    (GDBusArgInfo **) &_egdbus_session_cs_signal_info_account_removed_ARG_pointers,
    NULL
  },
  "account-removed"
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_signal_info_account_changed_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_signal_info_account_changed_ARG_pointers[] =
{
  &_egdbus_session_cs_signal_info_account_changed_ARG_uid,
  NULL
};

static const _ExtendedGDBusSignalInfo _egdbus_session_cs_signal_info_account_changed =
{
  {
    -1,
    "AccountChanged",
    (GDBusArgInfo **) &_egdbus_session_cs_signal_info_account_changed_ARG_pointers,
    NULL
  },
  "account-changed"
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_signal_info_get_password_ARG_title =
{
  {
    -1,
    "title",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_signal_info_get_password_ARG_prompt =
{
  {
    -1,
    "prompt",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_session_cs_signal_info_get_password_ARG_key =
{
  {
    -1,
    "key",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_session_cs_signal_info_get_password_ARG_pointers[] =
{
  &_egdbus_session_cs_signal_info_get_password_ARG_title,
  &_egdbus_session_cs_signal_info_get_password_ARG_prompt,
  &_egdbus_session_cs_signal_info_get_password_ARG_key,
  NULL
};

static const _ExtendedGDBusSignalInfo _egdbus_session_cs_signal_info_get_password =
{
  {
    -1,
    "GetPassword",
    (GDBusArgInfo **) &_egdbus_session_cs_signal_info_get_password_ARG_pointers,
    NULL
  },
  "get-password"
};

static const _ExtendedGDBusSignalInfo * const _egdbus_session_cs_signal_info_pointers[] =
{
  &_egdbus_session_cs_signal_info_send_receive_complete,
  &_egdbus_session_cs_signal_info_account_added,
  &_egdbus_session_cs_signal_info_account_removed,
  &_egdbus_session_cs_signal_info_account_changed,
  &_egdbus_session_cs_signal_info_get_password,
  NULL
};

static const GDBusAnnotationInfo _egdbus_session_cs_annotation_info_0 =
{
  -1,
  "org.freedesktop.DBus.GLib.CSymbol",
  "EMailDataSession",
  NULL
};

static const GDBusAnnotationInfo * const _egdbus_session_cs_annotation_info_pointers[] =
{
  &_egdbus_session_cs_annotation_info_0,
  NULL
};

static const GDBusInterfaceInfo _egdbus_session_cs_interface_info =
{
  -1,
  "org.gnome.evolution.dataserver.mail.Session",
  (GDBusMethodInfo **) &_egdbus_session_cs_method_info_pointers,
  (GDBusSignalInfo **) &_egdbus_session_cs_signal_info_pointers,
  NULL,
  (GDBusAnnotationInfo **) &_egdbus_session_cs_annotation_info_pointers
};


GDBusInterfaceInfo *
egdbus_session_cs_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_egdbus_session_cs_interface_info;
}



static void
egdbus_session_cs_default_init (EGdbusSessionCSIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  g_signal_new ("handle-get-store",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, handle_get_store),
    g_signal_accumulator_true_handled,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  g_signal_new ("handle-get-local-store",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, handle_get_local_store),
    g_signal_accumulator_true_handled,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  g_signal_new ("handle-add-password",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, handle_add_password),
    g_signal_accumulator_true_handled,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    4,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_BOOLEAN);

  g_signal_new ("handle-get-local-folder",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, handle_get_local_folder),
    g_signal_accumulator_true_handled,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  g_signal_new ("handle-get-folder-from-uri",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, handle_get_folder_from_uri),
    g_signal_accumulator_true_handled,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  g_signal_new ("handle-send-receive",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, handle_send_receive),
    g_signal_accumulator_true_handled,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  g_signal_new ("handle-fetch-account",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, handle_fetch_account),
    g_signal_accumulator_true_handled,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  g_signal_new ("handle-fetch-old-messages",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, handle_fetch_old_messages),
    g_signal_accumulator_true_handled,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_INT);

  g_signal_new ("handle-cancel-operations",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, handle_cancel_operations),
    g_signal_accumulator_true_handled,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  g_signal_new ("send-receive-complete",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, send_receive_complete),
    NULL,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  g_signal_new ("account-added",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, account_added),
    NULL,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  g_signal_new ("account-removed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, account_removed),
    NULL,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  g_signal_new ("account-changed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, account_changed),
    NULL,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  g_signal_new ("get-password",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusSessionCSIface, get_password),
    NULL,
    NULL,
    _cclosure_marshal_generic,
    G_TYPE_NONE,
    3, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);

}

typedef EGdbusSessionCSIface EGdbusSessionCSInterface;
#define egdbus_session_cs_get_type egdbus_session_cs_get_gtype
G_DEFINE_INTERFACE (EGdbusSessionCS, egdbus_session_cs, G_TYPE_OBJECT);
#undef egdbus_session_cs_get_type

void
egdbus_session_cs_emit_send_receive_complete (
    EGdbusSessionCS *object)
{
  g_signal_emit_by_name (object, "send-receive-complete");
}

void
egdbus_session_cs_emit_account_added (
    EGdbusSessionCS *object,
    const gchar *uid)
{
  g_signal_emit_by_name (object, "account-added", uid);
}

void
egdbus_session_cs_emit_account_removed (
    EGdbusSessionCS *object,
    const gchar *uid)
{
  g_signal_emit_by_name (object, "account-removed", uid);
}

void
egdbus_session_cs_emit_account_changed (
    EGdbusSessionCS *object,
    const gchar *uid)
{
  g_signal_emit_by_name (object, "account-changed", uid);
}

void
egdbus_session_cs_emit_get_password (
    EGdbusSessionCS *object,
    const gchar *title,
    const gchar *prompt,
    const gchar *key)
{
  g_signal_emit_by_name (object, "get-password", title, prompt, key);
}

void
egdbus_session_cs_call_get_store (
    EGdbusSessionCS *proxy,
    const gchar *uri,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getStore",
    g_variant_new ("(s)",
                   uri),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

gboolean
egdbus_session_cs_call_get_store_finish (
    EGdbusSessionCS *proxy,
    gchar **out_store,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_store);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

gboolean
egdbus_session_cs_call_get_store_sync (
    EGdbusSessionCS *proxy,
    const gchar *uri,
    gchar **out_store,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getStore",
    g_variant_new ("(s)",
                   uri),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_store);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

void
egdbus_session_cs_call_get_local_store (
    EGdbusSessionCS *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getLocalStore",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

gboolean
egdbus_session_cs_call_get_local_store_finish (
    EGdbusSessionCS *proxy,
    gchar **out_store,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_store);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

gboolean
egdbus_session_cs_call_get_local_store_sync (
    EGdbusSessionCS *proxy,
    gchar **out_store,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getLocalStore",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_store);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

void
egdbus_session_cs_call_add_password (
    EGdbusSessionCS *proxy,
    const gchar *key,
    const gchar *password,
    gboolean remember,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "addPassword",
    g_variant_new ("(ssb)",
                   key,
                   password,
                   remember),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

gboolean
egdbus_session_cs_call_add_password_finish (
    EGdbusSessionCS *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

gboolean
egdbus_session_cs_call_add_password_sync (
    EGdbusSessionCS *proxy,
    const gchar *key,
    const gchar *password,
    gboolean remember,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "addPassword",
    g_variant_new ("(ssb)",
                   key,
                   password,
                   remember),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

void
egdbus_session_cs_call_get_local_folder (
    EGdbusSessionCS *proxy,
    const gchar *type,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getLocalFolder",
    g_variant_new ("(s)",
                   type),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

gboolean
egdbus_session_cs_call_get_local_folder_finish (
    EGdbusSessionCS *proxy,
    gchar **out_folder,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_folder);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

gboolean
egdbus_session_cs_call_get_local_folder_sync (
    EGdbusSessionCS *proxy,
    const gchar *type,
    gchar **out_folder,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getLocalFolder",
    g_variant_new ("(s)",
                   type),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_folder);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

void
egdbus_session_cs_call_get_folder_from_uri (
    EGdbusSessionCS *proxy,
    const gchar *uri,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getFolderFromUri",
    g_variant_new ("(s)",
                   uri),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

gboolean
egdbus_session_cs_call_get_folder_from_uri_finish (
    EGdbusSessionCS *proxy,
    gchar **out_folder,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_folder);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

gboolean
egdbus_session_cs_call_get_folder_from_uri_sync (
    EGdbusSessionCS *proxy,
    const gchar *uri,
    gchar **out_folder,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getFolderFromUri",
    g_variant_new ("(s)",
                   uri),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_folder);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

void
egdbus_session_cs_call_send_receive (
    EGdbusSessionCS *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "sendReceive",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

gboolean
egdbus_session_cs_call_send_receive_finish (
    EGdbusSessionCS *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

gboolean
egdbus_session_cs_call_send_receive_sync (
    EGdbusSessionCS *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "sendReceive",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

void
egdbus_session_cs_call_fetch_account (
    EGdbusSessionCS *proxy,
    const gchar *uid,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "fetchAccount",
    g_variant_new ("(s)",
                   uid),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

gboolean
egdbus_session_cs_call_fetch_account_finish (
    EGdbusSessionCS *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

gboolean
egdbus_session_cs_call_fetch_account_sync (
    EGdbusSessionCS *proxy,
    const gchar *uid,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "fetchAccount",
    g_variant_new ("(s)",
                   uid),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

void
egdbus_session_cs_call_fetch_old_messages (
    EGdbusSessionCS *proxy,
    const gchar *uid,
    gint count,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "fetchOldMessages",
    g_variant_new ("(si)",
                   uid,
                   count),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

gboolean
egdbus_session_cs_call_fetch_old_messages_finish (
    EGdbusSessionCS *proxy,
    gboolean *out_success,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

gboolean
egdbus_session_cs_call_fetch_old_messages_sync (
    EGdbusSessionCS *proxy,
    const gchar *uid,
    gint count,
    gboolean *out_success,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "fetchOldMessages",
    g_variant_new ("(si)",
                   uid,
                   count),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

void
egdbus_session_cs_call_cancel_operations (
    EGdbusSessionCS *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "cancelOperations",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

gboolean
egdbus_session_cs_call_cancel_operations_finish (
    EGdbusSessionCS *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

gboolean
egdbus_session_cs_call_cancel_operations_sync (
    EGdbusSessionCS *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "cancelOperations",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

void
egdbus_session_cs_complete_get_store (
    EGdbusSessionCS *object,
    GDBusMethodInvocation *invocation,
    const gchar *store)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(o)",
                   store));
}

void
egdbus_session_cs_complete_get_local_store (
    EGdbusSessionCS *object,
    GDBusMethodInvocation *invocation,
    const gchar *store)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(o)",
                   store));
}

void
egdbus_session_cs_complete_add_password (
    EGdbusSessionCS *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

void
egdbus_session_cs_complete_get_local_folder (
    EGdbusSessionCS *object,
    GDBusMethodInvocation *invocation,
    const gchar *folder)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(o)",
                   folder));
}

void
egdbus_session_cs_complete_get_folder_from_uri (
    EGdbusSessionCS *object,
    GDBusMethodInvocation *invocation,
    const gchar *folder)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(o)",
                   folder));
}

void
egdbus_session_cs_complete_send_receive (
    EGdbusSessionCS *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

void
egdbus_session_cs_complete_fetch_account (
    EGdbusSessionCS *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

void
egdbus_session_cs_complete_fetch_old_messages (
    EGdbusSessionCS *object,
    GDBusMethodInvocation *invocation,
    gboolean success)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(b)",
                   success));
}

void
egdbus_session_cs_complete_cancel_operations (
    EGdbusSessionCS *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

static void
egdbus_session_cs_proxy_iface_init (EGdbusSessionCSIface *iface)
{
}

#define egdbus_session_cs_proxy_get_type egdbus_session_cs_proxy_get_gtype
G_DEFINE_TYPE_WITH_CODE (EGdbusSessionCSProxy, egdbus_session_cs_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (EGDBUS_SESSION_TYPE_CS, egdbus_session_cs_proxy_iface_init));
#undef egdbus_session_cs_proxy_get_type

static void
egdbus_session_cs_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
egdbus_session_cs_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
egdbus_session_cs_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_egdbus_session_cs_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], EGDBUS_SESSION_TYPE_CS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, EGDBUS_SESSION_TYPE_CS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
egdbus_session_cs_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_egdbus_session_cs_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_egdbus_session_cs_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
egdbus_session_cs_proxy_init (EGdbusSessionCSProxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), egdbus_session_cs_interface_info ());
}

static void
egdbus_session_cs_proxy_class_init (EGdbusSessionCSProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = egdbus_session_cs_proxy_get_property;
  gobject_class->set_property = egdbus_session_cs_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = egdbus_session_cs_proxy_g_signal;
  proxy_class->g_properties_changed = egdbus_session_cs_proxy_g_properties_changed;

}
void
egdbus_session_cs_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (EGDBUS_SESSION_TYPE_CS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.evolution.dataserver.mail.Session", NULL);
}

EGdbusSessionCS *
egdbus_session_cs_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return EGDBUS_SESSION_CS (ret);
  else
    return NULL;
}

EGdbusSessionCS *
egdbus_session_cs_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (EGDBUS_SESSION_TYPE_CS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.evolution.dataserver.mail.Session", NULL);
  if (ret != NULL)
    return EGDBUS_SESSION_CS (ret);
  else
    return NULL;
}


void
egdbus_session_cs_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (EGDBUS_SESSION_TYPE_CS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.evolution.dataserver.mail.Session", NULL);
}

EGdbusSessionCS *
egdbus_session_cs_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return EGDBUS_SESSION_CS (ret);
  else
    return NULL;
}

EGdbusSessionCS *
egdbus_session_cs_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (EGDBUS_SESSION_TYPE_CS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.evolution.dataserver.mail.Session", NULL);
  if (ret != NULL)
    return EGDBUS_SESSION_CS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

struct _EGdbusSessionCSStubPrivate
{
  GValueArray *properties;
  GDBusObject *object;
  GDBusInterfaceFlags flags;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GDBusConnection *connection;
  gchar *object_path;
  GMainContext *context;
};

static void
_egdbus_session_cs_stub_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_interface_info_lookup_method ((GDBusInterfaceInfo *) &_egdbus_session_cs_interface_info, method_name);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 2);
  g_value_init (&paramv[0], EGDBUS_SESSION_TYPE_CS);
  g_value_set_object (&paramv[0], stub);
  g_value_init (&paramv[1], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[1], invocation);
  g_variant_iter_init (&iter, parameters);
  n = 2;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - 2];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, EGDBUS_SESSION_TYPE_CS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + 2; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_egdbus_session_cs_stub_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_egdbus_session_cs_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (stub), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (stub), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_egdbus_session_cs_stub_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_egdbus_session_cs_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (stub), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (stub), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _egdbus_session_cs_stub_vtable =
{
  _egdbus_session_cs_stub_handle_method_call,
  _egdbus_session_cs_stub_handle_get_property,
  _egdbus_session_cs_stub_handle_set_property
};

static GDBusInterfaceInfo *
egdbus_session_cs_stub_dbus_interface_get_info (GDBusInterface *interface)
{
  return egdbus_session_cs_interface_info ();
}

static GVariant *
egdbus_session_cs_stub_dbus_interface_get_properties (GDBusInterface *interface)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (interface);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_egdbus_session_cs_interface_info.properties == NULL)
    goto out;
  for (n = 0; _egdbus_session_cs_interface_info.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _egdbus_session_cs_interface_info.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _egdbus_session_cs_stub_handle_get_property (stub->priv->connection, NULL, stub->priv->object_path, "org.gnome.evolution.dataserver.mail.Session", info->name, NULL, stub);
          if (value != NULL)
            {
              if (g_variant_is_floating (value))
                g_variant_ref_sink (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
egdbus_session_cs_stub_dbus_interface_flush (GDBusInterface *interface)
{
}

static void
_egdbus_session_cs_on_object_unregistered (EGdbusSessionCSStub *stub)
{
  stub->priv->connection = NULL;
  g_free (stub->priv->object_path);
  stub->priv->object_path = NULL;
}

static guint
egdbus_session_cs_stub_dbus_interface_register_object (GDBusInterface *interface,  GDBusConnection *connection,
  const gchar *object_path,
  GError **error)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (interface);
  stub->priv->connection = connection;
  stub->priv->object_path = g_strdup (object_path);
  stub->priv->context = g_main_context_get_thread_default ();
  if (stub->priv->context != NULL)
    g_main_context_ref (stub->priv->context);
  return g_dbus_connection_register_object (connection, object_path, egdbus_session_cs_interface_info (), &_egdbus_session_cs_stub_vtable, stub, (GDestroyNotify) _egdbus_session_cs_on_object_unregistered, error);
}

static GDBusObject *
egdbus_session_cs_stub_dbus_interface_get_object (GDBusInterface *interface)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (interface);
  return stub->priv->object != NULL ? g_object_ref (stub->priv->object) : NULL;
}

static void
egdbus_session_cs_stub_dbus_interface_set_object (GDBusInterface *interface,  GDBusObject *object)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (interface);
  stub->priv->object = object;
}

static GDBusInterfaceFlags
egdbus_session_cs_stub_dbus_interface_get_flags (GDBusInterface *interface)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (interface);
  return stub->priv->flags;
}

static void
egdbus_session_cs_stub_dbus_interface_set_flags (GDBusInterface *interface,  GDBusInterfaceFlags flags)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (interface);
  stub->priv->flags = flags;
}

static void
_egdbus_session_cs_on_signal_send_receive_complete (
    EGdbusSessionCS *object)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (object);
  if (stub->priv->connection == NULL)
    return;
  g_dbus_connection_emit_signal (stub->priv->connection,
    NULL, stub->priv->object_path, "org.gnome.evolution.dataserver.mail.Session", "sendReceiveComplete",
    g_variant_new ("()"), NULL);
}

static void
_egdbus_session_cs_on_signal_account_added (
    EGdbusSessionCS *object,
    const gchar *uid)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (object);
  if (stub->priv->connection == NULL)
    return;
  g_dbus_connection_emit_signal (stub->priv->connection,
    NULL, stub->priv->object_path, "org.gnome.evolution.dataserver.mail.Session", "AccountAdded",
    g_variant_new ("(s)",
                   uid), NULL);
}

static void
_egdbus_session_cs_on_signal_account_removed (
    EGdbusSessionCS *object,
    const gchar *uid)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (object);
  if (stub->priv->connection == NULL)
    return;
  g_dbus_connection_emit_signal (stub->priv->connection,
    NULL, stub->priv->object_path, "org.gnome.evolution.dataserver.mail.Session", "AccountRemoved",
    g_variant_new ("(s)",
                   uid), NULL);
}

static void
_egdbus_session_cs_on_signal_account_changed (
    EGdbusSessionCS *object,
    const gchar *uid)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (object);
  if (stub->priv->connection == NULL)
    return;
  g_dbus_connection_emit_signal (stub->priv->connection,
    NULL, stub->priv->object_path, "org.gnome.evolution.dataserver.mail.Session", "AccountChanged",
    g_variant_new ("(s)",
                   uid), NULL);
}

static void
_egdbus_session_cs_on_signal_get_password (
    EGdbusSessionCS *object,
    const gchar *title,
    const gchar *prompt,
    const gchar *key)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (object);
  if (stub->priv->connection == NULL)
    return;
  g_dbus_connection_emit_signal (stub->priv->connection,
    NULL, stub->priv->object_path, "org.gnome.evolution.dataserver.mail.Session", "GetPassword",
    g_variant_new ("(sss)",
                   title,
                   prompt,
                   key), NULL);
}

static void
egdbus_session_cs_stub_iface_init (EGdbusSessionCSIface *iface)
{
  iface->send_receive_complete = _egdbus_session_cs_on_signal_send_receive_complete;
  iface->account_added = _egdbus_session_cs_on_signal_account_added;
  iface->account_removed = _egdbus_session_cs_on_signal_account_removed;
  iface->account_changed = _egdbus_session_cs_on_signal_account_changed;
  iface->get_password = _egdbus_session_cs_on_signal_get_password;
}

static void
egdbus_session_cs_stub_dbus_iface_init (GDBusInterfaceIface *iface)
{
  iface->get_info = egdbus_session_cs_stub_dbus_interface_get_info;
  iface->get_properties = egdbus_session_cs_stub_dbus_interface_get_properties;
  iface->flush = egdbus_session_cs_stub_dbus_interface_flush;
  iface->register_object = egdbus_session_cs_stub_dbus_interface_register_object;
  iface->get_object = egdbus_session_cs_stub_dbus_interface_get_object;
  iface->set_object = egdbus_session_cs_stub_dbus_interface_set_object;
  iface->get_flags = egdbus_session_cs_stub_dbus_interface_get_flags;
  iface->set_flags = egdbus_session_cs_stub_dbus_interface_set_flags;
}

#define egdbus_session_cs_stub_get_type egdbus_session_cs_stub_get_gtype
G_DEFINE_TYPE_WITH_CODE (EGdbusSessionCSStub, egdbus_session_cs_stub, G_TYPE_OBJECT,
                         G_IMPLEMENT_INTERFACE (EGDBUS_SESSION_TYPE_CS, egdbus_session_cs_stub_iface_init)
                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_INTERFACE, egdbus_session_cs_stub_dbus_iface_init));
#undef egdbus_session_cs_stub_get_type

static void
egdbus_session_cs_stub_finalize (GObject *object)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (object);
  g_list_foreach (stub->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (stub->priv->changed_properties);
  if (stub->priv->changed_properties_idle_source != NULL)
    g_source_destroy (stub->priv->changed_properties_idle_source);
  if (stub->priv->context != NULL)
    g_main_context_unref (stub->priv->context);
  G_OBJECT_CLASS (egdbus_session_cs_stub_parent_class)->finalize (object);
}

static void
egdbus_session_cs_stub_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  EGdbusSessionCSStub *stub = EGDBUS_SESSION_CS_STUB (object);
  g_assert (prop_id - 1 >= 0 && prop_id - 1 < 0);
  g_value_copy (&stub->priv->properties->values[prop_id - 1], value);
}

static void
egdbus_session_cs_stub_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
egdbus_session_cs_stub_init (EGdbusSessionCSStub *stub)
{
  stub->priv = G_TYPE_INSTANCE_GET_PRIVATE (stub, EGDBUS_SESSION_TYPE_CS_STUB, EGdbusSessionCSStubPrivate);
}

static void
egdbus_session_cs_stub_class_init (EGdbusSessionCSStubClass *klass)
{
  GObjectClass *gobject_class;

  g_type_class_add_private (klass, sizeof (EGdbusSessionCSStubPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = egdbus_session_cs_stub_finalize;
  gobject_class->get_property = egdbus_session_cs_stub_get_property;
  gobject_class->set_property = egdbus_session_cs_stub_set_property;

}

EGdbusSessionCS *
egdbus_session_cs_stub_new (void)
{
  return EGDBUS_SESSION_CS (g_object_new (EGDBUS_SESSION_TYPE_CS_STUB, NULL));
}

/* ------------------------------------------------------------------------
 * Code for proxy manager
 * ------------------------------------------------------------------------
 */

/* ------------------------------------------------------------------------ */

#define egdbus_session_proxy_manager_get_type egdbus_session_proxy_manager_get_gtype
G_DEFINE_TYPE (EGdbusSessionProxyManager, egdbus_session_proxy_manager, G_TYPE_DBUS_PROXY_MANAGER);
#undef egdbus_session_proxy_manager_get_type

static void
egdbus_session_proxy_manager_init (EGdbusSessionProxyManager *manager)
{
}

static void
egdbus_session_proxy_manager_class_init (EGdbusSessionProxyManagerClass *klass)
{
}

static GType
_egdbus_session_proxy_manager_get_proxy_type_func (GDBusProxyManager *manager, const gchar *object_path, const gchar *interface_name, gpointer user_data)
{
  GType ret;
  ret = G_TYPE_DBUS_PROXY;
  if (FALSE)
    ;
  else if (g_strcmp0 (interface_name, "org.gnome.evolution.dataserver.mail.Session") == 0)
    ret = EGDBUS_SESSION_TYPE_CS_PROXY;
  return ret;
}

GDBusProxyTypeFunc
egdbus_session_proxy_manager_get_proxy_type_func (void)
{
  return _egdbus_session_proxy_manager_get_proxy_type_func;
}

void
egdbus_session_proxy_manager_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (EGDBUS_SESSION_TYPE_PROXY_MANAGER, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", _egdbus_session_proxy_manager_get_proxy_type_func, NULL);
}

GDBusProxyManager *
egdbus_session_proxy_manager_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return G_DBUS_PROXY_MANAGER (ret);
  else
    return NULL;
}

GDBusProxyManager *
egdbus_session_proxy_manager_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (EGDBUS_SESSION_TYPE_PROXY_MANAGER, cancellable, error, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", _egdbus_session_proxy_manager_get_proxy_type_func, NULL);
  if (ret != NULL)
    return G_DBUS_PROXY_MANAGER (ret);
  else
    return NULL;
}


void
egdbus_session_proxy_manager_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (EGDBUS_SESSION_TYPE_PROXY_MANAGER, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", _egdbus_session_proxy_manager_get_proxy_type_func, NULL);
}

GDBusProxyManager *
egdbus_session_proxy_manager_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return G_DBUS_PROXY_MANAGER (ret);
  else
    return NULL;
}

GDBusProxyManager *
egdbus_session_proxy_manager_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (EGDBUS_SESSION_TYPE_PROXY_MANAGER, cancellable, error, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", _egdbus_session_proxy_manager_get_proxy_type_func, NULL);
  if (ret != NULL)
    return G_DBUS_PROXY_MANAGER (ret);
  else
    return NULL;
}


